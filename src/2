package
{
  import org.flixel.*;
  import flash.display.BitmapData;
  import flash.display.BitmapDataChannel;
  import flash.geom.Rectangle;
  import flash.geom.Point;

  public class PlayState extends FlxState
  {
    public static const SIN_RATE:Number = 10;
    public static const HUE_RATE:Number = 10;

    var palette:FlxSprite;
    var dingus:FlxSprite;
    var sin:Number = 0;
    var hue:Number = 0;

    var colors:Array = [];
    var shiftedColors:Array = [];
    var shiftedHSB:Array = [];

    override public function create():void {
      dingus = new FlxSprite();
      dingus.loadGraphic(Assets.CMY);
      dingus.x = 4*dingus.width;
      dingus.y = 4*dingus.height;
      dingus.scale = new FlxPoint(8,8);
      add(dingus);

      palette = new FlxSprite();
      palette.loadGraphic(Assets.CMYPalette);
      for(var x:int = 0; x < palette.width; x++) {
        for(var y:int = 0; y < palette.width; y++) {
          colors.push(palette.pixels.getPixel32(x, y));
        }
      }

      for each(var color:uint in colors) {
        shiftedHSB.push(FlxU.getHSB(color));
      }
    }

    override public function update():void {
      hue += FlxG.elapsed * HUE_RATE;
      var hsb:Array;
      for (var i:int = 0; i < shiftedHSB.length; i++) {
        hsb = shiftedHSB[i];
        shiftedColors[i] = FlxU.makeColorFromHSB((hsb[0] + hue) % 360, hsb[1], hsb[2]);
      }
      super.update();
    }

    override public function draw():void {
      super.draw();

      hueShiftCamera(FlxG.camera);
      aberrateCamera(FlxG.camera);
      /*
        var blueBuffer:BitmapData = new BitmapData(FlxG.camera.width, FlxG.camera.height, true, 0x00000000);
        blueBuffer.copyChannel(buffer, sourceRect, new Point(4,5), BitmapDataChannel.ALPHA, BitmapDataChannel.ALPHA); 
        blueBuffer.copyChannel(buffer, sourceRect, new Point(4,5), BitmapDataChannel.BLUE, BitmapDataChannel.BLUE); 
        FlxG.camera.buffer.draw(blueBuffer, null, null, "add");

        var greenBuffer:BitmapData = new BitmapData(FlxG.camera.width, FlxG.camera.height, true, 0x00000000);
        greenBuffer.copyChannel(buffer, sourceRect, new Point(3,4), BitmapDataChannel.ALPHA, BitmapDataChannel.ALPHA); 
        greenBuffer.copyChannel(buffer, sourceRect, new Point(3,4), BitmapDataChannel.GREEN, BitmapDataChannel.GREEN); 
        FlxG.camera.buffer.draw(greenBuffer, null, null, "add");
      */
    }

    protected function hueShiftCamera(camera:FlxCamera):void {
      var colorIndex:int = -1;

      for(var row:uint = 0; row < camera.height; row++) {
        for(var column:uint = 0; column < camera.width; column++) {
          colorIndex = shiftedColors.indexOf(camera.buffer.getPixel32(column,row));
					if(colorIndex > -1) {
						camera.buffer.setPixel32(column,row,shiftedColors[colorIndex]);
					}
				}
			}
    }

    protected function aberrateCamera(camera:FlxCamera):void {
      sin += FlxG.elapsed * SIN_RATE;
      var buffer:BitmapData = camera.buffer.clone();
      camera.fill(0xff000000);

      var sourceRect:Rectangle = new Rectangle(0,0,camera.width, camera.height);

      var colorBuffer:BitmapData;
      var channels:Array = [BitmapDataChannel.RED, BitmapDataChannel.BLUE, BitmapDataChannel.GREEN];
     
      for each(var channel:uint in channels) { 
        colorBuffer = new BitmapData(camera.width, camera.height, true, 0x00000000);       
        var point:Point = new Point(Math.sin(channel + sin) * 2 + channel, Math.cos(channel + sin) * 2 + channel);
         
        colorBuffer.copyChannel(buffer,
          sourceRect,
          point,
          BitmapDataChannel.ALPHA,
          BitmapDataChannel.ALPHA);

        colorBuffer.copyChannel(buffer, sourceRect, point, channel, channel); 
        camera.buffer.draw(colorBuffer, null, null, "add");
      }
    }
  }
}
